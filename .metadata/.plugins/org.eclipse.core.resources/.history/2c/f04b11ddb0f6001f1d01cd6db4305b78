import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.prefs.NodeChangeEvent;

import org.apache.commons.io.FileUtils;
import org.eclipse.jdt.core.dom.AST;
import org.eclipse.jdt.core.dom.ASTParser;
import org.eclipse.jdt.core.dom.ASTVisitor;
import org.eclipse.jdt.core.dom.CompilationUnit;
import org.eclipse.jdt.core.dom.MethodDeclaration;
import org.eclipse.jdt.core.dom.MethodInvocation;
import org.eclipse.jdt.core.dom.SimpleName;
import org.eclipse.jdt.core.dom.SingleVariableDeclaration;
import org.eclipse.jdt.core.dom.VariableDeclarationFragment;
import org.eclipse.jdt.core.dom.VariableDeclarationStatement;

public class JDT_Test {

	public void run() throws IOException {
		// Read source file content 
		String content = FileUtils.readFileToString(new File("./src/ContentReader.java"));
		
		// Set up the AST Parser
		ASTParser parser = ASTParser.newParser(AST.JLS8);
		// Give the content to the parser
		parser.setSource(content.toCharArray());
		parser.setKind(ASTParser.K_COMPILATION_UNIT);
		
		final CompilationUnit cu = (CompilationUnit) parser.createAST(null);
		
		// Store method signatures (Key: Method name, Value: Method Signature concatenated together)
	    List<String> methodDeclarations = new ArrayList<>();												// List of Method Declaration and vars declared inside its body
	    List<String> methodCalls = new ArrayList<>();
	    Map<String, List<String>> methodReceivers = new HashMap<>();
	    Map<String, List<String>> methodArguments = new HashMap<>();
        
		// AST Visitor
		cu.accept(new ASTVisitor() {
			@Override
			public boolean visit(MethodDeclaration node) {
				// Get Method's name, return type, start and end line		
				String methodName = node.getName().getIdentifier();											// Method's name
		        int currLine = cu.getLineNumber(node.getStartPosition()); 									// Current line number
		        int endLine = cu.getLineNumber(node.getStartPosition() + node.getLength()); 				// End line number
		        methodDeclarations.add("Method Declaration: " + methodName + "\nStart Line: " + currLine + "\nEnd Line: " + endLine);
				
				// List all variables in the method's body
		        List<String> variablesInMethod = new ArrayList<>();
		        for (Object fragment : node.getBody().statements()) {										// get all lines ("statement") from the method's body
		            if (fragment instanceof VariableDeclarationStatement) {									// check if current line is an instance of var declaration (eg:int x = 10)
		                VariableDeclarationStatement varDecl = (VariableDeclarationStatement) fragment;		
		                for (Object varFragment : varDecl.fragments()) {									// return "fragment" inside varDecl (eg: x = 10, y = 10)
		                    VariableDeclarationFragment var = (VariableDeclarationFragment) varFragment;
		                    variablesInMethod.add(var.getName().toString());
		                }
		            }
		        }
		        
		        // Add variable declaration if the list is not empty
		        if (!variablesInMethod.isEmpty()) {
		            methodDeclarations.add("Variables declared in this method: " + String.join(", ", variablesInMethod));
		        }         
		        
		        return super.visit(node);
			}
		});	
		
	    // Testing
	    System.out.println("Methods Found:");
	    for (String declaration : methodDeclarations) {
	        System.out.println(declaration + "\n");	     
	    }
	}
	
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		JDT_Test driver = new JDT_Test();
		try {
			driver.run();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
